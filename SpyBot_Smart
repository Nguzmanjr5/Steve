from ib_insync import *
from ta.momentum import RSIIndicator
from ta.trend import SMAIndicator
import yfinance as yf
from datetime import datetime, time as dtime
import pytz
import time
import os
import smtplib
from email.mime.text import MIMEText
from dotenv import load_dotenv
import math

# =========================
# üîê Load Env Vars
# =========================
load_dotenv()
EMAIL_USER = os.getenv("EMAIL_USER")
EMAIL_PASS = os.getenv("EMAIL_PASS")

# =========================
# üìß Email Alert
# =========================
def send_email(subject, body):
    msg = MIMEText(body)
    msg['Subject'] = subject
    msg['From'] = EMAIL_USER
    msg['To'] = EMAIL_USER

    try:
        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
            server.login(EMAIL_USER, EMAIL_PASS)
            server.send_message(msg)
        print("‚úÖ Email sent!")
    except Exception as e:
        print(f"‚ùå Email error: {e}")

# =========================
# ‚è∞ Market Hours Check
# =========================
def is_market_open():
    eastern = pytz.timezone('US/Eastern')
    now = datetime.now(eastern).time()
    # Basic check for regular trading hours, does not account for holidays/early closes.
    return dtime(9, 30) <= now <= dtime(16, 0)

# =========================
# üìà Get SPY Price from Yahoo
# =========================
def get_spy_price():
    spy = yf.Ticker("SPY")
    data = spy.history(period="1d", interval="1m")
    if data.empty:
        print("‚ö†Ô∏è No price data.")
        return None, None
    latest = data.iloc[-1]
    price = latest['Close']
    timestamp = latest.name
    print(f"üí∞ SPY Price: {price} at {timestamp}")
    return price, timestamp

# =========================
# üìä Technical Indicators
# =========================
def get_tech_indicators():
    spy = yf.Ticker("SPY")
    data = spy.history(period="3d", interval="5m")
    if data.empty:
        print("‚ö†Ô∏è Failed to fetch historical data.")
        return None, None

    close = data['Close']
    sma = SMAIndicator(close, window=14).sma_indicator().iloc[-1]
    rsi = RSIIndicator(close, window=14).rsi().iloc[-1]

    print(f"üìà SMA: {sma:.2f} | RSI: {rsi:.2f}")
    return sma, rsi

# =========================
# üí∏ Option Price from Yahoo
# =========================
def get_option_price_yahoo(expiry, strike, direction):
    spy = yf.Ticker("SPY")
    try:
        opt_chain = spy.option_chain(expiry)
        chain = opt_chain.calls if direction == 'C' else opt_chain.puts

        opt = chain[chain['strike'] == strike]
        if opt.empty:
            print("‚ö†Ô∏è Option not found.")
            return None

        bid = opt['bid'].values[0]
        ask = opt['ask'].values[0]
        last = opt['lastPrice'].values[0]

        if (bid == 0 and ask == 0) and last > 0:
            mid = last
        elif bid == 0 and ask == 0 and last == 0:
            print("‚ö†Ô∏è Option has no bid, ask, or last price. Unreliable.")
            return None # Avoid using arbitrary fallback price for reliability.
        
        else:
            mid = round((bid + ask) / 2, 2)

        if mid <= 0:
            print("‚ö†Ô∏è Invalid option price.")
            return None

        print(f"üíµ Option Price: Bid={bid} | Ask={ask} | Mid={mid}")
        return mid

    except Exception as e:
        print(f"‚ùå Failed to fetch option price: {e}")
        return None

# =========================
# üí∞ Account Balance
# =========================
def get_account_balance():
    account_summary = ib.accountSummary()
    df = util.df(account_summary)
    cash_row = df[df['tag'] == 'NetLiquidation']
    if cash_row.empty:
        print("‚ö†Ô∏è Could not fetch account balance.")
        return 0
    cash = float(cash_row['value'].values[0])
    print(f"üíµ Account Balance: ${cash}")
    return cash

# =========================
# üí∏ Close Open Position
# =========================
def close_position(contract):
    positions = ib.positions()
    for pos in positions:
        if pos.contract.conId == contract.conId:
            qty = pos.position
            order = MarketOrder('SELL', qty)
            trade = ib.placeOrder(contract, order) 
            print("üì§ Sell order placed.")

            while trade.isActive():
                ib.waitOnUpdate()

            if trade.orderStatus.status == 'Filled':
                msg = f"‚úÖ Position closed: {trade.orderStatus}"
                print(msg)
                send_email("Position Closed", msg)
                return True # Success
            else:
                msg = f"‚ùå Failed to close (Status: {trade.orderStatus.status})"
                print(msg)
                send_email("Close Error", msg)
                return False # Failure or other status
            
    print("‚ö†Ô∏è No matching open position found.")
    return False # Position not found

# =========================
# ‚è≥ Trailing Stop Monitor (Yahoo Powered)
# =========================
def monitor_position_with_trailing(strike, direction, expiry, entry_price, contract, dynamic_trailing_percent):
    highest_price = entry_price

    print(f"üõ°Ô∏è Monitoring {contract.localSymbol if hasattr(contract, 'localSymbol') else 'contract'} with entry {entry_price:.2f}, initial trailing stop at {dynamic_trailing_percent}%.")

    while True:
        if not is_market_open():
            print(f"‚è∞ Market closed while monitoring {contract.localSymbol if hasattr(contract, 'localSymbol') else 'contract'}. Attempting to close position.")
            if not close_position(contract): 
                error_msg = f"ALERT: Attempt to close {contract.localSymbol if hasattr(contract, 'localSymbol') else 'contract'} at EOD did not confirm 'Filled'."
                print(error_msg)
                send_email(f"Potential Issue: EOD Close - {contract.localSymbol if hasattr(contract, 'localSymbol') else 'contract'}", error_msg)
            break

        current_price = get_option_price_yahoo(expiry, strike, direction)

        if current_price is None:
            print(f"‚ö†Ô∏è No price data for {contract.localSymbol if hasattr(contract, 'localSymbol') else 'contract'}, retrying...")
            time.sleep(10)
            continue

        if current_price > highest_price:
            highest_price = current_price
            print(f"üî∫ New High for {contract.localSymbol if hasattr(contract, 'localSymbol') else 'contract'}: {highest_price:.2f}")

        stop_price = highest_price * (1 - dynamic_trailing_percent / 100)

        print(f"üìä {contract.localSymbol if hasattr(contract, 'localSymbol') else 'contract'} - Current: {current_price:.2f} | High: {highest_price:.2f} | Stop: {stop_price:.2f} (Trail: {dynamic_trailing_percent}%)")

        if current_price <= stop_price:
            print(f"üõë Trailing stop hit for {contract.localSymbol if hasattr(contract, 'localSymbol') else 'contract'}! Attempting to close...")
            if not close_position(contract): 
                error_msg = f"ALERT: Attempt to close {contract.localSymbol if hasattr(contract, 'localSymbol') else 'contract'} on stop-loss did not confirm 'Filled'."
                print(error_msg)
                send_email(f"Potential Issue: Stop Loss Close - {contract.localSymbol if hasattr(contract, 'localSymbol') else 'contract'}", error_msg)
            break

        time.sleep(30)

# =========================
# üß† Trading Logic
# =========================
def trade_spy_options():
    price, _ = get_spy_price()
    if price is None:
        send_email("Bot Error", "Failed to fetch SPY price.")
        return

    sma, rsi = get_tech_indicators()
    if sma is None or rsi is None or math.isnan(sma) or math.isnan(rsi):
        send_email("Bot Error", "Failed to fetch valid indicators (SMA or RSI).")
        return

    direction = None
    if price > sma and rsi < 70:
        direction = "C"
    elif price < sma and rsi > 30:
        direction = "P"

    if direction is None:
        print("üö¶ No trade signal.")
        return

    print(f"üöÄ Trade Signal: {direction} | Price: {price:.2f}, SMA: {sma:.2f}, RSI: {rsi:.2f}")

    # --- Dynamic Risk Adjustment based on VIX ---
    # User-adjustable default parameters:
    base_allocation_percentage = 0.10  # Default percentage of balance to allocate per trade
    base_trailing_percent = 5.0        # Default trailing stop percentage

    current_allocation_percentage = base_allocation_percentage
    current_trailing_percent = base_trailing_percent 

    try:
        vix_ticker = yf.Ticker("^VIX")
        vix_data = vix_ticker.history(period="1d") 
        if not vix_data.empty:
            current_vix = vix_data['Close'].iloc[-1]
            print(f"üìä Current VIX: {current_vix:.2f}")

            # User-adjustable VIX thresholds and risk modifications:
            # These are example values; tune them based on backtesting and risk preference.
            high_vix_threshold = 24.0
            low_vix_threshold = 17.0

            if current_vix > high_vix_threshold: # High volatility scenario
                current_allocation_percentage = base_allocation_percentage * 0.5  # Example: Halve allocation
                current_trailing_percent = 20.0  # Example: Wider trailing stop
                print(f"üî∂ High VIX ({current_vix:.2f}): Adjusting allocation to {current_allocation_percentage*100:.1f}%, trailing stop to {current_trailing_percent}%.")
            elif current_vix < low_vix_threshold: # Low volatility scenario
                # Note: Increasing allocation in low VIX should be done cautiously.
                current_allocation_percentage = base_allocation_percentage * 1.15 # Example: Slightly increase allocation
                current_trailing_percent = 10.0  # Example: Tighter trailing stop
                print(f"üî∑ Low VIX ({current_vix:.2f}): Adjusting allocation to {current_allocation_percentage*100:.1f}%, trailing stop to {current_trailing_percent}%.")
            else: # Normal VIX range
                print(f"üî∑ Normal VIX ({current_vix:.2f}): Using default allocation {current_allocation_percentage*100:.1f}%, trailing stop {current_trailing_percent}%.")
        else:
            print("‚ö†Ô∏è Could not fetch VIX data, using default risk parameters.")
            
    except Exception as e:
        print(f"‚ùå Error fetching VIX: {e}. Using default risk parameters.")
    
    expiry = yf.Ticker("SPY").options[1] # Typically the next weekly expiry
    strike = round(price)

    option_price = get_option_price_yahoo(expiry, strike, direction)
    if option_price is None or option_price <= 0 or math.isnan(option_price):
        print("‚ö†Ô∏è Invalid option price. Skipping trade.")
        send_email("Trade Error", "Option price is invalid or missing. Skipping trade.")
        return

    contract = Option(
        symbol='SPY',
        lastTradeDateOrContractMonth=expiry.replace("-", ""),
        strike=strike,
        right=direction,
        exchange='SMART',
        currency='USD'
    )

    ib.qualifyContracts(contract)
    print(f"üìÑ Contract: {contract}")

    balance = get_account_balance()
    allocation = balance * current_allocation_percentage
    print(f"üíµ Calculated allocation amount: ${allocation:.2f} ({current_allocation_percentage*100:.1f}% of balance)")

    qty = int(allocation // (option_price * 100))
    if qty < 1:
        print(f"‚ö†Ô∏è Not enough balance for {current_allocation_percentage*100:.1f}% allocation. Need ${option_price*100:.2f} for 1 contract, have ${allocation:.2f} allocated for trade.")
        return

    print(f"üßÆ Buying {qty} contracts at ${option_price} (Adjusted Allocation: {current_allocation_percentage*100:.1f}%)")

    order = MarketOrder('BUY', qty)
    trade = ib.placeOrder(contract, order)
    print("üì• Buy order placed.")

    while trade.isActive():
        ib.waitOnUpdate()

    if trade.orderStatus.status != 'Filled':
        msg = f"‚ùå Buy order failed: {trade.orderStatus}"
        print(msg)
        send_email("Trade Error", msg)
        return

    entry_price_filled = trade.orderStatus.avgFillPrice
    print(f"‚úÖ Entry filled at {entry_price_filled}")

    send_email(
        "Trade Executed",
        f"{direction} Option Filled at {entry_price_filled} x {qty}\nContract: {contract}\nAllocation: {current_allocation_percentage*100:.1f}% (VIX: {current_vix if 'current_vix' in locals() else 'N/A'})"
    )

    monitor_position_with_trailing(strike, direction, expiry, entry_price_filled, contract, current_trailing_percent)

# =========================
# üîÑ Main Loop
# =========================
ib = IB()
try:
    ib.connect('127.0.0.1', 7497, clientId=1)
    print("üîó Connected to IBKR.")

    while True:
        if is_market_open():
            try:
                trade_spy_options()
            except Exception as e:
                print(f"‚ö†Ô∏è Error in trade_spy_options: {e}") # Clarified error source
                send_email("Bot Runtime Error", f"Error encountered in trade_spy_options: {str(e)}")
        else:
            print("‚è∞ Market closed. Sleeping...")
            time.sleep(300) # Check every 5 minutes

        # Consider the overall loop sleep time.
        # If a trade happens, trade_spy_options can take a while (due to monitor_position_with_trailing).
        # This sleep ensures a pause even if no trade signal or if market was closed.
        time.sleep(300) 

except ConnectionRefusedError: # Specific exception for connection failure
    print(f"‚ùå IBKR Connection Refused. Ensure TWS/Gateway is running and API connections are enabled.")
    # Optionally send an email here if critical
except Exception as e: # General catch-all for other startup errors
    print(f"‚ùå Main loop or connection error: {e}")
    send_email("Bot Critical Error", f"Main loop or connection error: {str(e)}")
finally:
    if ib.isConnected(): # Disconnect only if connected
        print("üîó Disconnecting from IBKR.")
        ib.disconnect()
    else:
        print("üîó Was not connected to IBKR or already disconnected.")
