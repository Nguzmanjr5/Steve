from ib_insync import *
from ta.momentum import RSIIndicator
from ta.trend import SMAIndicator
import yfinance as yf
from datetime import datetime, time as dtime
import pytz
import time
import os
import smtplib
from email.mime.text import MIMEText
from dotenv import load_dotenv
import math

# =========================
# üîê Load Env Vars
# =========================
load_dotenv()
EMAIL_USER = os.getenv("EMAIL_USER")
EMAIL_PASS = os.getenv("EMAIL_PASS")

# =========================
# üìß Email Alert
# =========================
def send_email(subject, body):
    msg = MIMEText(body)
    msg['Subject'] = subject
    msg['From'] = EMAIL_USER
    msg['To'] = EMAIL_USER

    try:
        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
            server.login(EMAIL_USER, EMAIL_PASS)
            server.send_message(msg)
        print("‚úÖ Email sent!")
    except Exception as e:
        print(f"‚ùå Email error: {e}")

# =========================
# ‚è∞ Market Hours Check
# =========================
def is_market_open():
    eastern = pytz.timezone('US/Eastern')
    now = datetime.now(eastern).time()
    return dtime(9, 30) <= now <= dtime(16, 0)

# =========================
# üìà Get SPY Price from Yahoo
# =========================
def get_spy_price():
    spy = yf.Ticker("SPY")
    data = spy.history(period="1d", interval="1m")
    if data.empty:
        print("‚ö†Ô∏è No price data.")
        return None, None
    latest = data.iloc[-1]
    price = latest['Close']
    timestamp = latest.name
    print(f"üí∞ SPY Price: {price} at {timestamp}")
    return price, timestamp

# =========================
# üìä Technical Indicators
# =========================
def get_tech_indicators():
    spy = yf.Ticker("SPY")
    data = spy.history(period="3d", interval="5m")
    if data.empty:
        print("‚ö†Ô∏è Failed to fetch historical data.")
        return None, None

    close = data['Close']
    sma = SMAIndicator(close, window=14).sma_indicator().iloc[-1]
    rsi = RSIIndicator(close, window=14).rsi().iloc[-1]

    print(f"üìà SMA: {sma:.2f} | RSI: {rsi:.2f}")
    return sma, rsi

# =========================
# üí∏ Option Price from Yahoo
# =========================
def get_option_price_yahoo(expiry, strike, direction):
    spy = yf.Ticker("SPY")
    try:
        opt_chain = spy.option_chain(expiry)
        chain = opt_chain.calls if direction == 'C' else opt_chain.puts

        opt = chain[chain['strike'] == strike]
        if opt.empty:
            print("‚ö†Ô∏è Option not found.")
            return None

        bid = opt['bid'].values[0]
        ask = opt['ask'].values[0]
        last = opt['lastPrice'].values[0]

        if (bid == 0 and ask == 0) and last > 0:
            mid = last
        elif bid == 0 and ask == 0 and last == 0:
            print("‚ö†Ô∏è Option has no bid, ask, or last price. Unreliable.")
            return None # Using an arbitrary price here could lead to incorrect trailing stop calculations and premature exits.

        # elif bid == 0 and ask == 0 and last == 0:
        #     mid = round(strike * 0.01, 2)  # Emergency fallback
        
        else:
            mid = round((bid + ask) / 2, 2)

        if mid <= 0:
            print("‚ö†Ô∏è Invalid option price.")
            return None

        print(f"üíµ Option Price: Bid={bid} | Ask={ask} | Mid={mid}")
        return mid

    except Exception as e:
        print(f"‚ùå Failed to fetch option price: {e}")
        return None

# =========================
# üí∞ Account Balance
# =========================
def get_account_balance():
    account_summary = ib.accountSummary()
    df = util.df(account_summary)
    cash_row = df[df['tag'] == 'NetLiquidation']
    if cash_row.empty:
        print("‚ö†Ô∏è Could not fetch account balance.")
        return 0
    cash = float(cash_row['value'].values[0])
    print(f"üíµ Account Balance: ${cash}")
    return cash

# =========================
# üí∏ Close Open Position
# =========================
def close_position(contract):
    positions = ib.positions()
    for pos in positions:
        if pos.contract.conId == contract.conId:
            qty = pos.position
            order = MarketOrder('SELL', qty)
            trade = ib.placeOrder(contract, order) 
            print("üì§ Sell order placed.")

            # Original wait loop - NOW CORRECTLY INDENTED
            while trade.isActive():
                ib.waitOnUpdate()

            # Simplified check and return - NOW CORRECTLY INDENTED
            if trade.orderStatus.status == 'Filled':
                msg = f"‚úÖ Position closed: {trade.orderStatus}"
                print(msg)
                send_email("Position Closed", msg)
                return True # Explicitly return True for success
            else:
                msg = f"‚ùå Failed to close (Status: {trade.orderStatus.status})"
                print(msg)
                send_email("Close Error", msg)
                return False # Explicitly return False for other outcomes
            # If the position was found and processed, we return from inside this block.
            # No need for a 'break' if conId is unique and we return.

    print("‚ö†Ô∏è No matching open position found.")
    return False # Return False if position was not found after checking all

# =========================
# ‚è≥ Trailing Stop Monitor (Yahoo Powered)
# =========================
def monitor_position_with_trailing(strike, direction, expiry, entry_price, contract):
    trailing_percent = 5
    highest_price = entry_price

    # while True: loop NOW CORRECTLY INDENTED
    while True:
        if not is_market_open():
            print("‚è∞ Market closed while monitoring. Attempting to close position.")
            if not close_position(contract): # Check the boolean return
                # Minimal alert for failure
                error_msg = f"ALERT: Attempt to close {contract.localSymbol} at EOD did not confirm 'Filled'." # Assuming contract has localSymbol
                print(error_msg)
                send_email(f"Potential Issue: EOD Close - {contract.localSymbol if hasattr(contract, 'localSymbol') else 'contract'}", error_msg)
            break

        current_price = get_option_price_yahoo(expiry, strike, direction)

        if current_price is None:
            print("‚ö†Ô∏è No price data, retrying...")
            time.sleep(10)
            continue

        if current_price > highest_price:
            highest_price = current_price
            print(f"üî∫ New High: {highest_price}")

        stop_price = highest_price * (1 - trailing_percent / 100)

        print(f"üìä Current Price: {current_price} | Stop Price: {stop_price}")

        if current_price <= stop_price:
            print("üõë Trailing stop hit! Attempting to close...")
            if not close_position(contract): # Check the boolean return
                # Minimal alert for failure
                error_msg = f"ALERT: Attempt to close {contract.localSymbol} on stop-loss did not confirm 'Filled'." # Assuming contract has localSymbol
                print(error_msg)
                send_email(f"Potential Issue: Stop Loss Close - {contract.localSymbol if hasattr(contract, 'localSymbol') else 'contract'}", error_msg)
            break

        time.sleep(30)

# =========================
# üß† Trading Logic
# =========================
def trade_spy_options():
    price, _ = get_spy_price()
    if price is None:
        send_email("Bot Error", "Failed to fetch SPY price.")
        return

    sma, rsi = get_tech_indicators()
    if sma is None or rsi is None:
        send_email("Bot Error", "Failed to fetch indicators.")
        return

    direction = None
    if price > sma and rsi < 70:
        direction = "C"
    elif price < sma and rsi > 30:
        direction = "P"

    if direction is None:
        print("üö¶ No trade signal.")
        return

    print(f"üöÄ Trade Signal: {direction}")

    expiry = yf.Ticker("SPY").options[1]  # Use next expiry (weekly) for stability
    strike = round(price)

    option_price = get_option_price_yahoo(expiry, strike, direction)
    if option_price is None or option_price <= 0 or math.isnan(option_price):
        print("‚ö†Ô∏è Invalid option price. Skipping trade.")
        send_email("Trade Error", "Option price is invalid or missing. Skipping trade.")
        return

    contract = Option(
        symbol='SPY',
        lastTradeDateOrContractMonth=expiry.replace("-", ""),
        strike=strike,
        right=direction,
        exchange='SMART',
        currency='USD'
    )

    ib.qualifyContracts(contract)
    print(f"üìÑ Contract: {contract}")

    balance = get_account_balance()
    allocation = balance * 0.10

    qty = int(allocation // (option_price * 100))
    if qty < 1:
        print("‚ö†Ô∏è Not enough balance to buy any contracts.")
        return

    print(f"üßÆ Buying {qty} contracts at ${option_price}")

    order = MarketOrder('BUY', qty)
    trade = ib.placeOrder(contract, order)
    print("üì• Buy order placed.")

    while trade.isActive():
        ib.waitOnUpdate()

    if trade.orderStatus.status != 'Filled':
        msg = f"‚ùå Buy order failed: {trade.orderStatus}"
        print(msg)
        send_email("Trade Error", msg)
        return

    entry_price = trade.orderStatus.avgFillPrice
    print(f"‚úÖ Entry filled at {entry_price}")

    send_email(
        "Trade Executed",
        f"{direction} Option Filled at {entry_price} x {qty}\nContract: {contract}"
    )

    monitor_position_with_trailing(strike, direction, expiry, entry_price, contract)

# =========================
# üîÑ Main Loop
# =========================
ib = IB()
try:
    ib.connect('127.0.0.1', 7497, clientId=1)
    print("üîó Connected to IBKR.")

    while True:
        if is_market_open():
            try:
                trade_spy_options()
            except Exception as e:
                print(f"‚ö†Ô∏è Error: {e}")
                send_email("Bot Error", str(e))
        else:
            print("‚è∞ Market closed. Sleeping...")
            time.sleep(300)

        time.sleep(300)

except Exception as e:
    print(f"‚ùå Connection error: {e}")
    send_email("Bot Error", str(e))
finally:
    ib.disconnect()
