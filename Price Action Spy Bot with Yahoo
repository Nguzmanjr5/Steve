from ib_insync import *
from ta.momentum import RSIIndicator
from ta.trend import SMAIndicator
import yfinance as yf
import pandas as pd
from datetime import datetime, time as dtime
import pytz
import time
import os
import smtplib
from email.mime.text import MIMEText
from dotenv import load_dotenv

# =========================
# üîê Load Environment Variables
# =========================
load_dotenv()
EMAIL_USER = os.getenv("EMAIL_USER")
EMAIL_PASS = os.getenv("EMAIL_PASS")

# =========================
# üìß Email Alert
# =========================
def send_email(subject, body):
    msg = MIMEText(body)
    msg['Subject'] = subject
    msg['From'] = EMAIL_USER
    msg['To'] = EMAIL_USER

    try:
        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
            server.login(EMAIL_USER, EMAIL_PASS)
            server.send_message(msg)
        print("‚úÖ Email sent!")
    except Exception as e:
        print(f"‚ùå Email error: {e}")

# =========================
# ‚è∞ Market Hours Check
# =========================
def is_market_open():
    eastern = pytz.timezone('US/Eastern')
    now = datetime.now(eastern).time()
    return dtime(9, 30) <= now <= dtime(16, 0)

# =========================
# üìà Get SPY Price from Yahoo
# =========================
def get_spy_price():
    spy = yf.Ticker("SPY")
    data = spy.history(period="1d", interval="1m")
    if data.empty:
        print("‚ö†Ô∏è No price data.")
        return None, None
    latest = data.iloc[-1]
    price = latest['Close']
    timestamp = latest.name
    print(f"üí∞ SPY Price: {price} at {timestamp}")
    return price, timestamp

# =========================
# üìä Technical Indicators
# =========================
def get_tech_indicators():
    spy = yf.Ticker("SPY")
    data = spy.history(period="3d", interval="5m")
    if data.empty:
        print("‚ö†Ô∏è Failed to fetch historical data.")
        return None, None

    close = data['Close']
    sma = SMAIndicator(close, window=14).sma_indicator().iloc[-1]
    rsi = RSIIndicator(close, window=14).rsi().iloc[-1]

    print(f"üìà SMA: {sma:.2f} | RSI: {rsi:.2f}")
    return sma, rsi

# =========================
# üí∞ Account Balance
# =========================
def get_account_balance():
    account_summary = ib.accountSummary()
    cash_row = account_summary.loc[account_summary['Tag'] == 'NetLiquidation']
    cash = float(cash_row['Value'].values[0])
    print(f"üíµ Account Balance: ${cash}")
    return cash

# =========================
# üí∏ Close Open Position
# =========================
def close_position(contract):
    positions = ib.positions()
    for pos in positions:
        if pos.contract.conId == contract.conId:
            qty = pos.position
            order = MarketOrder('SELL', qty)
            trade = ib.placeOrder(contract, order)
            print("üì§ Sell order placed.")
            trade.waitUntilDone()

            if trade.orderStatus.status == 'Filled':
                msg = f"‚úÖ Position closed: {trade.orderStatus}"
                print(msg)
                send_email("Position Closed", msg)
            else:
                msg = f"‚ùå Failed to close: {trade.orderStatus}"
                print(msg)
                send_email("Close Error", msg)
            return

    print("‚ö†Ô∏è No matching open position found.")

# =========================
# ‚è≥ Trailing Stop Monitor
# =========================
def monitor_position_with_trailing(contract, entry_price):
    trailing_percent = 5  # % trailing stop
    highest_price = entry_price

    while True:
        market_data = ib.reqMktData(contract, '', False, False)
        ib.sleep(2)

        current_price = market_data.last
        if current_price is None:
            print("‚ö†Ô∏è No price data, retrying...")
            continue

        if current_price > highest_price:
            highest_price = current_price
            print(f"üî∫ New High: {highest_price}")

        stop_price = highest_price * (1 - trailing_percent / 100)

        print(f"üìä Current Price: {current_price} | Stop Price: {stop_price}")

        if current_price <= stop_price:
            print("üõë Trailing stop hit! Closing...")
            close_position(contract)
            break

        time.sleep(30)  # Check every 30 seconds

# =========================
# üß† Trading Logic
# =========================
def trade_spy_options():
    price, _ = get_spy_price()
    if price is None:
        send_email("Bot Error", "Failed to fetch SPY price.")
        return

    sma, rsi = get_tech_indicators()
    if sma is None or rsi is None:
        send_email("Bot Error", "Failed to fetch indicators.")
        return

    direction = None
    if price > sma and rsi < 70:
        direction = "C"  # Call
    elif price < sma and rsi > 30:
        direction = "P"  # Put

    if direction is None:
        print("üö¶ No trade signal.")
        return

    print(f"üöÄ Trade Signal: {direction}")

    # =========================
    # üìù Define Option Contract
    # =========================
    expiry = (datetime.now().strftime('%Y%m%d'))  # Today expiry (example)
    strike = round(price)  # ATM strike

    contract = Option(
        symbol='SPY',
        lastTradeDateOrContractMonth=expiry,
        strike=strike,
        right=direction,
        exchange='SMART',
        currency='USD'
    )

    ib.qualifyContracts(contract)
    print(f"üìÑ Contract: {contract}")

    # =========================
    # üè¶ Get Buying Power
    # =========================
    balance = get_account_balance()
    allocation = balance * 0.10  # 10% of account

    market_data = ib.reqMktData(contract, '', False, False)
    ib.sleep(2)
    option_price = market_data.last

    if option_price is None or option_price <= 0:
        print("‚ö†Ô∏è Invalid option price. Skipping trade.")
        return

    qty = int(allocation // (option_price * 100))
    if qty < 1:
        print("‚ö†Ô∏è Not enough balance to buy any contracts.")
        return

    print(f"üßÆ Buying {qty} contracts at ${option_price}")

    # =========================
    # üõí Place Buy Order
    # =========================
    order = MarketOrder('BUY', qty)
    trade = ib.placeOrder(contract, order)
    print("üì• Buy order placed.")
    trade.waitUntilDone()

    if trade.orderStatus.status != 'Filled':
        msg = f"‚ùå Buy order failed: {trade.orderStatus}"
        print(msg)
        send_email("Trade Error", msg)
        return

    entry_price = trade.orderStatus.avgFillPrice
    print(f"‚úÖ Entry filled at {entry_price}")

    send_email(
        "Trade Executed",
        f"{direction} Option Filled at {entry_price} x {qty}\nContract: {contract}"
    )

    # üî• Monitor with trailing stop
    monitor_position_with_trailing(contract, entry_price)

# =========================
# üîÑ Main Loop
# =========================
ib = IB()
try:
    ib.connect('127.0.0.1', 7497, clientId=1)
    print("üîó Connected to IBKR.")

    while True:
        if is_market_open():
            try:
                trade_spy_options()
            except Exception as e:
                print(f"‚ö†Ô∏è Error: {e}")
                send_email("Bot Error", str(e))
        else:
            print("‚è∞ Market closed. Sleeping...")
            time.sleep(300)  # Sleep 5 mins if market closed

        time.sleep(300)  # Check every 5 mins

except Exception as e:
    print(f"‚ùå Connection error: {e}")
    send_email("Bot Error", str(e))
finally:
    ib.disconnect()
